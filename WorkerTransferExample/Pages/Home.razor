@page "/"
@using SpawnDev.BlazorJS
@using SpawnDev.BlazorJS.JSObjects
@using SpawnDev.BlazorJS.WebWorkers
@using System.Security.Cryptography
@using System.Diagnostics

<PageTitle>WorkerTransfer Example</PageTitle>

<h1>WorkerTransfer Example</h1>

<button class="btn btn-primary" @onclick="Run">Run</button>

<pre role="status">@status</pre>

@code {
    [Inject]
    WebWorkerService WebWorkerService { get; set; } = default!;

    string status = "";

    // generate some random data for the example
    byte[] bytes = RandomNumberGenerator.GetBytes(50 * 1024 * 1024);

    void Log(string msg)
    {
        status += msg + "\n";
        StateHasChanged();
    }

    void LogClear()
    {
        status = "";
        StateHasChanged();
    }

    private async Task Run()
    {
        LogClear();

        {
            Log($"ArrayBuffer without WorkerTransfer...");

            // process the ArrayBuffer in a worker without using WorkerTransfer
            // here for comparison purposes
            var sw = Stopwatch.StartNew();

            // get bytes as a Uint8Array
            using var uint8Array = new Uint8Array(bytes);

            //  get the underlying ArrayBuffer
            using var arrayBufferOrig = uint8Array.Buffer;
            using var arrayBufferReturned1 = await WebWorkerService.TaskPool.Run(() => ProcessFrameNoTransfer(arrayBufferOrig));

            // arrayBufferOrig is not detached and can still be used (indicates it was not transferred to the worker)
            Log($"ArrayBuffer is detached: {arrayBufferOrig.Detached}");

            // pull back into .Net so it more fairly compares to the byte[] method
            var bytesReadBack = arrayBufferReturned1.ReadBytes();

            sw.Stop();
            Log($"Processed without WorkerTransfer {arrayBufferReturned1.ByteLength} bytes in {sw.ElapsedMilliseconds} ms\n");
        }

        {
            Log($"ArrayBuffer with WorkerTransfer...");

            // process the ArrayBuffer in a worker using WorkerTransfer
            // the original will become detached
            var sw = Stopwatch.StartNew();

            // get bytes as a Uint8Array
            using var uint8Array = new Uint8Array(bytes);

            //  get the underlying ArrayBuffer
            using var arrayBufferOrig = uint8Array.Buffer;
            using var arrayBufferReturned1 = await WebWorkerService.TaskPool.Run(() => ProcessFrame(arrayBufferOrig));

            // arrayBufferOrig is now detached and cannot be used (indicates it was transferred to the worker)
            Log($"ArrayBuffer is detached: {arrayBufferOrig.Detached}");

            // pull back into .Net so it more fairly compares to the byte[] method
            var bytesReadBack = arrayBufferReturned1.ReadBytes();

            sw.Stop();
            Log($"Processed with WorkerTransfer {arrayBufferReturned1.ByteLength} bytes in {sw.ElapsedMilliseconds} ms\n");
        }

        {
            Log($"byte[] - transferable and ArrayBuffer used by the dispatcher automatically...");

            // process the byte[] in a worker (while byte[] itself is not transferrable, transferrable is used under the hood to prevent copying where possible)
            // here for comparison purposes
            var sw = Stopwatch.StartNew();
            var bytesReadBack = await WebWorkerService.TaskPool.Run(() => ProcessFrameByteArray(bytes));

            // arrayBufferOrig is not used directly. write to the log like the other tests do.
            Log($"ArrayBuffer is detached: {false}");

            // the data is already in .Net (other methods do it manually for a fair comparison)

            sw.Stop();
            Log($"Processed byte[] {bytesReadBack.Length} bytes in {sw.ElapsedMilliseconds} ms\n");
        }
    }

    [return: WorkerTransfer]
    static async Task<ArrayBuffer> ProcessFrame([WorkerTransfer] ArrayBuffer arrayBuffer)
    {
        // read in the data and write back out so it compares more equally with the other methods
        var data = arrayBuffer.ReadBytes();
        var retunrnedArrayBuffer = new Uint8Array(data).Buffer;
        Console.WriteLine($"Processing ArrayBuffer with WorkerTransfer {data.Length} bytes in worker");
        return retunrnedArrayBuffer;
    }

    static async Task<ArrayBuffer> ProcessFrameNoTransfer(ArrayBuffer arrayBuffer)
    {
        // read in the data and write back out so it compares more equally with the other methods
        var data = arrayBuffer.ReadBytes();
        var retunrnedArrayBuffer = new Uint8Array(data).Buffer;
        Console.WriteLine($"Processing ArrayBuffer without WorkerTransfer {data.Length} bytes in worker");
        return retunrnedArrayBuffer;
    }

    static async Task<byte[]> ProcessFrameByteArray(byte[] data)
    {
        // write to console to indicate data was received
        Console.WriteLine($"Processing byte[] {data.Length} bytes in worker");
        return data;
    }
}
